---
title: Overview
description: Learn how to use the litesvm-token crate for testing with SPL tokens
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

## Overview

The `litesvm-token` crate provides utilities for working with SPL tokens in your LiteSVM tests. LiteSVM includes SPL Token programs by default, making it straightforward to test token-related functionality in your Solana programs.

## Installation

Make sure you have all the needed dependencies:

```bash
cargo add --dev litesvm litesvm-token solana-sdk spl-token spl-associated-token-account
```

## Understanding Token Account Creation

In Solana, creating token accounts requires two separate instructions due to the separation of concerns between programs. This is a fundamental pattern you'll use throughout token testing.

### Why Two Instructions?

<Steps>
<Step>
**System Program creates the account**
- Allocates space on the blockchain
- Assigns ownership to Token Program
- Transfers rent-exempt lamports
</Step>

<Step>
**Token Program initializes the account**
- Sets the mint (which token type)
- Sets the owner (who controls the tokens)
- Initializes amount to 0
</Step>
</Steps>

This separation ensures security and modularity - the System Program handles SOL and account creation, while the Token Program handles all token-specific logic.

### Associated Token Accounts

Associated Token Accounts (ATAs) simplify this process:

```rust
// Manual token account creation requires:
// 1. Generate keypair for the account
// 2. Calculate space needed
// 3. Create account with System Program
// 4. Initialize with Token Program

// ATA creation is simpler:
// - Deterministic address (no keypair needed)
// - Single instruction handles both steps
// - Same address every time for owner+mint combination
```

<Callout type="tip">
**Best Practice**: Always use Associated Token Accounts unless you have a specific reason not to. They're deterministic, easier to manage, and prevent common errors.
</Callout>

## Basic Setup

Here's how to set up a basic token testing environment:

```rust
use litesvm::LiteSVM;
use litesvm_token::{CreateMint, CreateAssociatedTokenAccount, MintTo};
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};

#[test]
fn test_token_operations() {
    // Initialize LiteSVM
    let mut svm = LiteSVM::new();

    // Create and fund payer
    let payer = Keypair::new();
    svm.airdrop(&payer.pubkey(), 10_000_000_000).unwrap();

    // Ready for token operations!
}
```

## Quick Example

Here's a complete example of creating a token mint and minting tokens:

```rust
use litesvm::LiteSVM;
use litesvm_token::{CreateMint, CreateAssociatedTokenAccount, MintTo};
use solana_sdk::signature::{Keypair, Signer};

#[test]
fn test_create_and_mint_tokens() {
    let mut svm = LiteSVM::new();

    // Setup accounts
    let payer = Keypair::new();
    let mint = Keypair::new();
    let mint_authority = Keypair::new();
    let recipient = Keypair::new();

    // Fund the payer
    svm.airdrop(&payer.pubkey(), 10_000_000_000).unwrap();

    // Create mint with 9 decimals (like SOL)
    svm.create_mint(
        &payer,
        &mint,
        &mint_authority.pubkey(),
        None, // No freeze authority
        9,    // Decimals
    ).unwrap();

    // Create recipient's token account
    let recipient_ata = svm.create_associated_token_account(
        &payer,
        &recipient.pubkey(),
        &mint.pubkey(),
    ).unwrap();

    // Mint 100 tokens
    let amount = 100 * 10_u64.pow(9); // Account for decimals
    svm.mint_to(
        &payer,
        &mint.pubkey(),
        &recipient_ata,
        &mint_authority,
        amount,
    ).unwrap();

    // Verify balance
    let account = svm.get_account(&recipient_ata).unwrap();
    let token_account = spl_token::state::Account::unpack(&account.data).unwrap();
    assert_eq!(token_account.amount, amount);
}
```

## Key Concepts

### Token Decimals

Most tokens use decimals to represent fractional amounts:

```rust
// SOL has 9 decimals
let one_sol = 10_u64.pow(9);  // 1_000_000_000 lamports

// USDC has 6 decimals
let one_usdc = 10_u64.pow(6); // 1_000_000 micro-USDC

// Always account for decimals in calculations
let amount_tokens = 100;
let amount_raw = amount_tokens * 10_u64.pow(decimals as u32);
```

### Account Relationships

Understanding the relationships between accounts is crucial:

- **Mint Account**: Defines the token (supply, decimals, authorities)
- **Token Account**: Holds tokens for a specific owner
- **Associated Token Account**: Deterministic token account for an owner+mint pair
- **Mint Authority**: Can create new tokens
- **Freeze Authority**: Can freeze token accounts (optional)

## Common Patterns

### Testing Helper Pattern

Create a test context to reduce boilerplate:

```rust
struct TestContext {
    svm: LiteSVM,
    payer: Keypair,
    mint: Pubkey,
    mint_authority: Keypair,
}

impl TestContext {
    fn new() -> Self {
        let mut svm = LiteSVM::new();
        let payer = Keypair::new();
        let mint_keypair = Keypair::new();
        let mint_authority = Keypair::new();

        // Setup
        svm.airdrop(&payer.pubkey(), 10_000_000_000).unwrap();
        svm.create_mint(
            &payer,
            &mint_keypair,
            &mint_authority.pubkey(),
            None,
            9,
        ).unwrap();

        Self {
            svm,
            payer,
            mint: mint_keypair.pubkey(),
            mint_authority,
        }
    }

    fn create_user_with_tokens(&mut self, amount: u64) -> (Keypair, Pubkey) {
        let user = Keypair::new();
        let user_ata = self.svm.create_associated_token_account(
            &self.payer,
            &user.pubkey(),
            &self.mint,
        ).unwrap();

        if amount > 0 {
            self.svm.mint_to(
                &self.payer,
                &self.mint,
                &user_ata,
                &self.mint_authority,
                amount,
            ).unwrap();
        }

        (user, user_ata)
    }
}
```

## Best Practices

<Callout type="tip">
1. **Always use ATAs when possible** - They're deterministic and easier to work with
2. **Account for decimals** - Create helper functions for token amounts
3. **Test edge cases** - Zero amounts, maximum amounts, insufficient balances
4. **Verify state changes** - Always check balances after operations
5. **Use helper functions** - Reduce test boilerplate with reusable patterns
</Callout>

## Troubleshooting

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `AccountNotFound` | Trying to use an account that doesn't exist | Ensure account is created before use |
| `AccountAlreadyInitialized` | Trying to initialize an already initialized account | Check if account exists before creating |
| `InsufficientFunds` | Not enough lamports for rent or tokens for transfer | Ensure sufficient funding/minting |
| `OwnerMismatch` | Account owned by wrong program | Verify correct program ID when creating |

## Next Steps

- **[Token Operations →](/docs/testing-with-spl-tokens/token-operations)** - Learn about minting, transfers, and other operations
- **[Basic Examples →](/docs/examples)** - See complete token testing examples
- **[Advanced Concepts →](/docs/advanced)** - Advanced token testing techniques