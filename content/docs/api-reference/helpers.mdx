---
title: Helper Functions
description: API reference for litesvm-token helper functions and utilities
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# Helper Functions

The `litesvm-token` package provides convenient helper functions for working with SPL tokens in tests.

## Installation

```toml
[dev-dependencies]
litesvm = "0.6.1"
litesvm-token = "0.6.1"
```

## Token Mint Operations

### `CreateMint`

Creates a new SPL token mint.

```rust
pub struct CreateMint<'a> {
    pub mint: &'a Pubkey,
    pub authority: &'a Pubkey,
    pub freeze_authority: Option<&'a Pubkey>,
    pub decimals: u8,
}
```

<Callout type="warning">
  **Important**: ALL mints must be properly initialized before use, even if you don't plan to mint tokens.
  Uninitialized mints cause `InvalidOwner` errors.
</Callout>

#### Methods

```rust
impl CreateMint<'_> {
    pub fn new(
        mint: &Pubkey,
        authority: &Pubkey,
        freeze_authority: Option<&Pubkey>,
        decimals: u8,
    ) -> Self

    pub fn instructions(&self, signers: &[&Keypair]) -> Vec<Instruction>
}
```

#### Example

```rust
use litesvm_token::CreateMint;
use solana_sdk::signature::Keypair;

let authority = Keypair::new();
let mint = Keypair::new();

// Create mint with 9 decimals (like SOL)
let create_mint = CreateMint::new(
    &mint.pubkey(),
    &authority.pubkey(),
    Some(&authority.pubkey()), // Optional freeze authority
    9,
);

// Get instructions and send transaction
let instructions = create_mint.instructions(&[&authority, &mint]);
svm.send_transaction(instructions).unwrap();
```

#### Manual Mint Initialization

For more control, you can manually initialize mints:

```rust
fn initialize_mint(
    svm: &mut LiteSVM,
    authority: &Keypair,
    mint: &Keypair,
    decimals: u8,
) {
    let mint_rent = svm.minimum_balance_for_rent_exemption(82);

    // Create account
    let create_account_ix = system_instruction::create_account(
        &authority.pubkey(),
        &mint.pubkey(),
        mint_rent,
        82, // Mint account size
        &spl_token::id(),
    );

    // Initialize mint
    let init_mint_ix = spl_token::instruction::initialize_mint(
        &spl_token::id(),
        &mint.pubkey(),
        &authority.pubkey(),
        None, // No freeze authority
        decimals,
    ).unwrap();

    let tx = Transaction::new_signed_with_payer(
        &[create_account_ix, init_mint_ix],
        Some(&authority.pubkey()),
        &[authority, mint],
        svm.latest_blockhash(),
    );

    svm.send_transaction(tx).unwrap();
}
```

## Token Account Operations

### `CreateAssociatedTokenAccount`

Creates an Associated Token Account (ATA) for a wallet.

```rust
pub struct CreateAssociatedTokenAccount<'a> {
    pub funder: &'a Pubkey,
    pub owner: &'a Pubkey,
    pub mint: &'a Pubkey,
    pub token_program: &'a Pubkey,
}
```

<Callout type="info">
  **Note**: ATAs are deterministic addresses. If your program creates ATAs via CPI,
  you may need to pre-create them in tests to avoid privilege escalation errors.
</Callout>

#### Methods

```rust
impl CreateAssociatedTokenAccount<'_> {
    pub fn instruction(&self, signers: &[&Keypair]) -> Instruction
}
```

#### Example

```rust
use litesvm_token::CreateAssociatedTokenAccount;
use spl_associated_token_account::get_associated_token_address;

// Create ATA for owner
let create_ata = CreateAssociatedTokenAccount {
    funder: &payer.pubkey(),
    owner: &owner.pubkey(),
    mint: &mint.pubkey(),
    token_program: &spl_token::id(),
};

let ix = create_ata.instruction(&[&payer]);
svm.send_transaction(vec![ix]).unwrap();

// Get the deterministic ATA address
let ata = get_associated_token_address(
    &owner.pubkey(),
    &mint.pubkey(),
);

// Verify creation
let account = svm.get_token_account(&ata).unwrap();
assert_eq!(account.owner, owner.pubkey());
assert_eq!(account.mint, mint.pubkey());
```

#### Pre-creating ATAs for CPI

If your program creates ATAs internally:

```rust
// Pre-create ATAs to avoid CPI privilege escalation
let recipient_ata = get_associated_token_address(
    &recipient.pubkey(),
    &mint.pubkey(),
);

// Create before calling your program
let create_ata = CreateAssociatedTokenAccount {
    funder: &payer.pubkey(),
    owner: &recipient.pubkey(),
    mint: &mint.pubkey(),
    token_program: &spl_token::id(),
};

svm.send_transaction(create_ata.instruction(&[&payer])).unwrap();

// Now your program's CPI won't fail
```

## Token Operations

### `MintTo`

Mints new tokens to an account.

```rust
pub struct MintTo<'a> {
    pub mint: &'a Pubkey,
    pub destination: &'a Pubkey,
    pub authority: &'a Pubkey,
    pub amount: u64,
}
```

#### Methods

```rust
impl MintTo<'_> {
    pub fn instruction(&self, signers: &[&Keypair]) -> Instruction
    pub fn instruction_no_signature(&self) -> Instruction
}
```

#### Example

```rust
use litesvm_token::MintTo;

// Mint 1000 tokens (accounting for decimals)
let decimals = 6; // USDC-style decimals
let amount = 1000 * 10_u64.pow(decimals as u32);

let mint_to = MintTo {
    mint: &mint.pubkey(),
    destination: &recipient_ata,
    authority: &mint_authority.pubkey(),
    amount,
};

let ix = mint_to.instruction(&[&mint_authority]);
svm.send_transaction(vec![ix]).unwrap();

// Verify balance
let account = svm.get_token_account(&recipient_ata).unwrap();
assert_eq!(account.amount, amount);
```

### `Transfer`

Transfers tokens between accounts.

```rust
pub struct Transfer<'a> {
    pub source: &'a Pubkey,
    pub destination: &'a Pubkey,
    pub authority: &'a Pubkey,
    pub amount: u64,
}
```

#### Methods

```rust
impl Transfer<'_> {
    pub fn instruction(&self, signers: &[&Keypair]) -> Instruction
    pub fn instruction_no_signature(&self) -> Instruction
}
```

#### Example

```rust
use litesvm_token::Transfer;

let transfer = Transfer {
    source: &sender_ata,
    destination: &recipient_ata,
    authority: &sender.pubkey(),
    amount: 100 * 10_u64.pow(decimals as u32),
};

let ix = transfer.instruction(&[&sender]);
svm.send_transaction(vec![ix]).unwrap();

// Verify balances
let sender_balance = svm.get_token_account(&sender_ata).unwrap();
let recipient_balance = svm.get_token_account(&recipient_ata).unwrap();
```

## Working with Decimals

Most tokens use decimals for fractional amounts:

```rust
// Common decimal values
const SOL_DECIMALS: u8 = 9;      // 1 SOL = 1_000_000_000 lamports
const USDC_DECIMALS: u8 = 6;     // 1 USDC = 1_000_000 units
const CUSTOM_DECIMALS: u8 = 8;   // 1 token = 100_000_000 units

// Helper function for converting human-readable amounts
fn to_token_amount(tokens: f64, decimals: u8) -> u64 {
    (tokens * 10_f64.powi(decimals as i32)) as u64
}

// Examples
let one_sol = to_token_amount(1.0, SOL_DECIMALS);          // 1_000_000_000
let half_usdc = to_token_amount(0.5, USDC_DECIMALS);       // 500_000
let custom = to_token_amount(123.456, CUSTOM_DECIMALS);    // 12_345_600_000
```

## Complete Token Test Example

Here's a complete example showing all token operations:

```rust
use litesvm::LiteSVM;
use litesvm_token::{CreateMint, CreateAssociatedTokenAccount, MintTo, Transfer};
use solana_sdk::signature::{Keypair, Signer};
use spl_associated_token_account::get_associated_token_address;

#[test]
fn test_complete_token_workflow() {
    let mut svm = LiteSVM::new();

    // Setup accounts
    let authority = Keypair::new();
    let mint = Keypair::new();
    let alice = Keypair::new();
    let bob = Keypair::new();

    // Fund accounts
    svm.airdrop(&authority.pubkey(), 10_000_000_000).unwrap();
    svm.airdrop(&alice.pubkey(), 1_000_000_000).unwrap();
    svm.airdrop(&bob.pubkey(), 1_000_000_000).unwrap();

    // 1. Create mint
    let decimals = 9;
    let create_mint = CreateMint::new(
        &mint.pubkey(),
        &authority.pubkey(),
        None,
        decimals,
    );
    svm.send_transaction(
        create_mint.instructions(&[&authority, &mint])
    ).unwrap();

    // 2. Create Associated Token Accounts
    let alice_ata = get_associated_token_address(
        &alice.pubkey(),
        &mint.pubkey(),
    );
    let bob_ata = get_associated_token_address(
        &bob.pubkey(),
        &mint.pubkey(),
    );

    // Create Alice's ATA
    let create_alice_ata = CreateAssociatedTokenAccount {
        funder: &alice.pubkey(),
        owner: &alice.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };
    svm.send_transaction(
        vec![create_alice_ata.instruction(&[&alice])]
    ).unwrap();

    // Create Bob's ATA
    let create_bob_ata = CreateAssociatedTokenAccount {
        funder: &bob.pubkey(),
        owner: &bob.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };
    svm.send_transaction(
        vec![create_bob_ata.instruction(&[&bob])]
    ).unwrap();

    // 3. Mint tokens to Alice
    let mint_amount = 1000 * 10_u64.pow(decimals as u32);
    let mint_to = MintTo {
        mint: &mint.pubkey(),
        destination: &alice_ata,
        authority: &authority.pubkey(),
        amount: mint_amount,
    };
    svm.send_transaction(
        vec![mint_to.instruction(&[&authority])]
    ).unwrap();

    // 4. Transfer tokens from Alice to Bob
    let transfer_amount = 250 * 10_u64.pow(decimals as u32);
    let transfer = Transfer {
        source: &alice_ata,
        destination: &bob_ata,
        authority: &alice.pubkey(),
        amount: transfer_amount,
    };
    svm.send_transaction(
        vec![transfer.instruction(&[&alice])]
    ).unwrap();

    // 5. Verify final balances
    let alice_balance = svm.get_token_account(&alice_ata).unwrap();
    let bob_balance = svm.get_token_account(&bob_ata).unwrap();

    assert_eq!(alice_balance.amount, mint_amount - transfer_amount);
    assert_eq!(bob_balance.amount, transfer_amount);

    println!("âœ… Token workflow complete!");
    println!("Alice balance: {} tokens", alice_balance.amount / 10_u64.pow(decimals as u32));
    println!("Bob balance: {} tokens", bob_balance.amount / 10_u64.pow(decimals as u32));
}
```

## Common Issues and Solutions

### InvalidOwner Error

**Problem**: Transaction fails with `InvalidOwner` error.

**Solution**: Ensure ALL mints are initialized:
```rust
// Even if you don't mint tokens, the mint must exist
initialize_mint(&mut svm, &authority, &mint, decimals);
```

### Privilege Escalation Error

**Problem**: CPI fails with "privilege escalated" error.

**Solutions**:
1. Pre-create ATAs before your program creates them
2. Ensure accounts receiving lamports are marked writable
3. Check that all required accounts are included in the instruction

### Account Not Found

**Problem**: Token operations fail with account not found.

**Solution**: Create token accounts before operations:
```rust
// Always create ATA before minting/transferring
let create_ata = CreateAssociatedTokenAccount { /* ... */ };
svm.send_transaction(create_ata.instruction(&[&payer])).unwrap();

// Now you can mint/transfer to the ATA
```

## Best Practices

1. **Always initialize mints** even if not actively used
2. **Pre-create ATAs** when your program will create them via CPI
3. **Check token account existence** before operations
4. **Use correct decimals** in amount calculations
5. **Verify balances** after token operations
6. **Handle errors** appropriately in production code