---
title: Best Practices
description: Recommended patterns and guidelines for testing with LiteSVM
---

import { Callout } from "fumadocs-ui/components/callout";
import { Card, Cards } from "fumadocs-ui/components/card";

# Best Practices

Follow these patterns and guidelines to write reliable, maintainable tests with LiteSVM.

## The Golden Rules

<Cards>
  <Card title="1. Always Initialize Mints" description="Even if not minting tokens" />
  <Card title="2. Match Program IDs to Keypairs" description="Critical for deployment" />
  <Card title="3. Mark Writable Accounts" description="When receiving lamports" />
  <Card title="4. Verify All Operations" description="Don't assume success" />
</Cards>

## Account Management

### Account Meta Configuration Rules

Understanding when accounts need to be writable is critical for avoiding privilege escalation errors.

```rust
// Rule 1: Fee payer (always first, always writable and signer)
AccountMeta::new(payer.pubkey(), true)

// Rule 2: Account receiving lamports (MUST be writable)
AccountMeta::new(recipient.pubkey(), false)  // Receiving SOL/closing account

// Rule 3: Account being debited (writable)
AccountMeta::new(source.pubkey(), true)   // If signer
AccountMeta::new(source.pubkey(), false)  // If PDA or program-owned

// Rule 4: Token accounts being modified (writable)
AccountMeta::new(token_account, false)  // Minting/transferring/burning

// Rule 5: Mint/Program accounts (usually readonly)
AccountMeta::new_readonly(mint.pubkey(), false)
AccountMeta::new_readonly(program_id, false)

// Rule 6: PDA accounts (never signers)
AccountMeta::new(pda_address, false)       // Writable PDA
AccountMeta::new_readonly(pda_address, false)  // Readonly PDA

// Rule 7: System accounts for reference (readonly)
AccountMeta::new_readonly(system_program::id(), false)
AccountMeta::new_readonly(spl_token::id(), false)
```

<Callout type="error">
  **Most Common Mistake**: Forgetting to mark accounts as writable when they receive lamports,
  even indirectly (e.g., from a closing account).
</Callout>

### Account Existence Checking

Always verify accounts exist before operations:

```rust
fn ensure_account_exists(
    svm: &LiteSVM,
    pubkey: &Pubkey,
    description: &str
) -> Result<(), String> {
    match svm.get_account(pubkey) {
        Some(account) => {
            println!("‚úÖ {} exists at {}", description, pubkey);
            println!("   Balance: {} lamports", account.lamports);
            println!("   Owner: {}", account.owner);
            Ok(())
        }
        None => {
            Err(format!("‚ùå {} not found at {}", description, pubkey))
        }
    }
}

// Use before critical operations
ensure_account_exists(&svm, &token_account, "Token account")?;
```

## Program Deployment Best Practices

### Always Use Keypair-Derived IDs

```rust
use solana_sdk::signature::read_keypair_file;

// Helper function for safe deployment
fn deploy_program(
    svm: &mut LiteSVM,
    keypair_path: &str,
    program_bytes: &[u8],
) -> Result<Pubkey, Box<dyn std::error::Error>> {
    // Read keypair to get correct ID
    let keypair = read_keypair_file(keypair_path)?;
    let program_id = keypair.pubkey();

    // Deploy
    svm.add_program(program_id, program_bytes)?;

    // Verify
    let account = svm.get_account(&program_id)
        .ok_or("Program not deployed")?;

    if !account.executable {
        return Err("Program not executable".into());
    }

    Ok(program_id)
}
```

### Deploy All Dependencies

```rust
fn deploy_all_programs(svm: &mut LiteSVM) -> Result<(), Box<dyn std::error::Error>> {
    // Your program
    let program_id = deploy_program(
        svm,
        "target/deploy/my_program-keypair.json",
        include_bytes!("../target/deploy/my_program.so"),
    )?;

    // Dependencies your program uses via CPI
    if uses_spl_token() {
        svm.add_program(
            spl_token::id(),
            include_bytes!("../spl_token.so"),
        )?;
    }

    if uses_associated_token_account() {
        svm.add_program(
            spl_associated_token_account::id(),
            include_bytes!("../spl_ata.so"),
        )?;
    }

    Ok(())
}
```

## Token Testing Patterns

### Initialize All Mints

<Callout type="warning">
  **Critical**: ALL mints referenced in your program must be initialized,
  even if you never mint tokens from them.
</Callout>

```rust
fn initialize_test_mints(
    svm: &mut LiteSVM,
    authority: &Keypair,
    mints: &[&Keypair],
) -> Result<(), Box<dyn std::error::Error>> {
    for mint in mints {
        let rent = svm.minimum_balance_for_rent_exemption(82);

        let create_ix = system_instruction::create_account(
            &authority.pubkey(),
            &mint.pubkey(),
            rent,
            82,
            &spl_token::id(),
        );

        let init_ix = spl_token::instruction::initialize_mint(
            &spl_token::id(),
            &mint.pubkey(),
            &authority.pubkey(),
            None,
            9, // decimals
        )?;

        let tx = Transaction::new_signed_with_payer(
            &[create_ix, init_ix],
            Some(&authority.pubkey()),
            &[authority, mint],
            svm.latest_blockhash(),
        );

        svm.send_transaction(tx)?;
    }

    Ok(())
}
```

### Pre-create Associated Token Accounts

Prevent CPI privilege escalation by pre-creating ATAs:

```rust
fn setup_token_accounts(
    svm: &mut LiteSVM,
    mint: &Pubkey,
    owners: &[&Pubkey],
) -> Result<Vec<Pubkey>, Box<dyn std::error::Error>> {
    let mut atas = Vec::new();

    for owner in owners {
        let ata = get_associated_token_address(owner, mint);

        // Check if already exists
        if svm.get_account(&ata).is_none() {
            let create_ata = CreateAssociatedTokenAccount {
                funder: owner,
                owner,
                mint,
                token_program: &spl_token::id(),
            };

            // Assuming owner has funds
            svm.send_transaction(create_ata.instruction(&[]))?;
        }

        atas.push(ata);
    }

    Ok(atas)
}
```

## Transaction Building

### Batch Related Operations

Group related instructions for efficiency:

```rust
fn batch_token_operations(
    svm: &mut LiteSVM,
    mint_authority: &Keypair,
    operations: Vec<TokenOperation>,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut instructions = Vec::new();

    for op in operations {
        match op {
            TokenOperation::Mint { destination, amount } => {
                let ix = spl_token::instruction::mint_to(
                    &spl_token::id(),
                    &mint,
                    &destination,
                    &mint_authority.pubkey(),
                    &[],
                    amount,
                )?;
                instructions.push(ix);
            }
            TokenOperation::Transfer { source, dest, amount } => {
                // Add transfer instruction
            }
        }
    }

    // Send all in one transaction
    let tx = Transaction::new_signed_with_payer(
        &instructions,
        Some(&mint_authority.pubkey()),
        &[mint_authority],
        svm.latest_blockhash(),
    );

    svm.send_transaction(tx)?;
    Ok(())
}
```

### Use Simulation for Complex Transactions

```rust
fn safe_send_transaction(
    svm: &mut LiteSVM,
    tx: Transaction,
) -> Result<TransactionMetadata, TransactionError> {
    // Simulate first
    match svm.simulate_transaction(&tx) {
        Ok(_) => {
            println!("‚úÖ Simulation successful, sending transaction...");
            svm.send_transaction(tx)
        }
        Err(err) => {
            println!("‚ùå Simulation failed: {:?}", err);
            // Log details for debugging
            if let Some(logs) = err.meta.as_ref().map(|m| &m.logs) {
                for log in logs {
                    println!("  {}", log);
                }
            }
            Err(err.err)
        }
    }
}
```

## Error Handling

### Comprehensive Error Reporting

```rust
fn execute_with_error_handling<T>(
    svm: &mut LiteSVM,
    operation: impl FnOnce(&mut LiteSVM) -> Result<T, TransactionError>,
    context: &str,
) -> Result<T, String> {
    match operation(svm) {
        Ok(result) => Ok(result),
        Err(err) => {
            let mut error_msg = format!("Failed to {}: {:?}", context, err);

            // Add detailed information
            if let Some(meta) = err.meta.as_ref() {
                error_msg.push_str("\n\nTransaction logs:");
                for log in &meta.logs {
                    error_msg.push_str(&format!("\n  {}", log));
                }
                error_msg.push_str(&format!(
                    "\n\nCompute units: {}",
                    meta.compute_units_consumed
                ));
            }

            // Provide suggestions based on error type
            match err {
                TransactionError::PrivilegeEscalation => {
                    error_msg.push_str("\n\nüí° Check account writability");
                }
                TransactionError::InvalidAccountOwner => {
                    error_msg.push_str("\n\nüí° Ensure all mints are initialized");
                }
                _ => {}
            }

            Err(error_msg)
        }
    }
}

// Usage
execute_with_error_handling(
    &mut svm,
    |svm| svm.send_transaction(tx),
    "send token transfer",
)?;
```

## Test Organization

### Test Setup Pattern

```rust
struct TestContext {
    svm: LiteSVM,
    program_id: Pubkey,
    authority: Keypair,
    mints: Vec<Pubkey>,
}

impl TestContext {
    fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let mut svm = LiteSVM::new();

        // Deploy program
        let program_keypair = read_keypair_file(
            "target/deploy/program-keypair.json"
        )?;
        let program_id = program_keypair.pubkey();
        svm.add_program(
            program_id,
            include_bytes!("../target/deploy/program.so"),
        )?;

        // Setup authority
        let authority = Keypair::new();
        svm.airdrop(&authority.pubkey(), 10_000_000_000)?;

        Ok(TestContext {
            svm,
            program_id,
            authority,
            mints: Vec::new(),
        })
    }

    fn create_mint(&mut self, decimals: u8) -> Result<Pubkey, Box<dyn std::error::Error>> {
        let mint = Keypair::new();
        // Initialize mint...
        self.mints.push(mint.pubkey());
        Ok(mint.pubkey())
    }
}

#[test]
fn test_with_context() {
    let mut ctx = TestContext::new().unwrap();
    let mint = ctx.create_mint(9).unwrap();
    // Run tests...
}
```

### Test Isolation

```rust
// Option 1: Fresh LiteSVM for each test
#[test]
fn test_isolated() {
    let mut svm = LiteSVM::new();
    // Test specific setup
}

// Option 2: Shared setup with cleanup
struct TestFixture {
    // Shared state
}

impl TestFixture {
    fn setup() -> Self {
        // Common setup
    }

    fn teardown(&mut self) {
        // Cleanup
    }
}
```

## Performance Optimization

### Minimize Transaction Count

```rust
// ‚ùå Inefficient: Multiple transactions
svm.send_transaction(create_mint_tx)?;
svm.send_transaction(create_ata_tx)?;
svm.send_transaction(mint_tokens_tx)?;

// ‚úÖ Efficient: Batch in one transaction
let tx = Transaction::new_signed_with_payer(
    &[create_mint_ix, create_ata_ix, mint_tokens_ix],
    Some(&payer.pubkey()),
    &signers,
    svm.latest_blockhash(),
);
svm.send_transaction(tx)?;
```

### Reuse Test Fixtures

```rust
lazy_static! {
    static ref PROGRAM_BYTES: Vec<u8> = {
        std::fs::read("target/deploy/program.so")
            .expect("Program not found")
    };
}

#[test]
fn test_with_cached_program() {
    let mut svm = LiteSVM::new();
    svm.add_program(program_id, &PROGRAM_BYTES)?;
}
```

## Debugging Tips

### Add Strategic Logging

```rust
fn debug_account_state(svm: &LiteSVM, pubkey: &Pubkey, label: &str) {
    println!("\n=== {} Account State ===", label);
    match svm.get_account(pubkey) {
        Some(account) => {
            println!("Address: {}", pubkey);
            println!("Balance: {} SOL", account.lamports as f64 / 1e9);
            println!("Owner: {}", account.owner);
            println!("Executable: {}", account.executable);
            println!("Data length: {} bytes", account.data.len());

            // If it's a token account, decode it
            if account.owner == spl_token::id() && account.data.len() == 165 {
                if let Ok(token_account) = svm.get_token_account(pubkey) {
                    println!("Token mint: {}", token_account.mint);
                    println!("Token owner: {}", token_account.owner);
                    println!("Token balance: {}", token_account.amount);
                }
            }
        }
        None => println!("Account not found: {}", pubkey),
    }
}

// Use throughout tests
debug_account_state(&svm, &escrow_account, "Escrow");
```

### Transaction Replay for Debugging

```rust
fn replay_transaction_with_logging(
    svm: &mut LiteSVM,
    tx: Transaction,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== Replaying Transaction ===");

    // Log each instruction
    for (i, ix) in tx.message.instructions.iter().enumerate() {
        println!("Instruction {}: Program {}", i, ix.program_id);
        for (j, account) in ix.accounts.iter().enumerate() {
            let meta = &tx.message.account_keys[*account as usize];
            println!("  Account {}: {}", j, meta);
        }
    }

    // Execute with detailed error handling
    match svm.send_transaction(tx) {
        Ok(result) => {
            println!("‚úÖ Success! Compute units: {}", result.compute_units_consumed);
            for log in result.logs {
                println!("  {}", log);
            }
            Ok(())
        }
        Err(err) => {
            println!("‚ùå Failed: {:?}", err);
            Err(err.into())
        }
    }
}
```

## Checklist for New Tests

Before considering a test complete, verify:

- [ ] All mints are initialized (even unused ones)
- [ ] Program IDs match keypairs
- [ ] Accounts receiving lamports are writable
- [ ] All dependencies are deployed
- [ ] Account existence is verified
- [ ] Transactions are error-handled
- [ ] Critical operations are verified
- [ ] Test cleanup is performed
- [ ] Edge cases are covered
- [ ] Errors are properly tested

## Summary

Following these best practices will help you:

1. **Avoid common pitfalls** that cause hours of debugging
2. **Write more maintainable** test code
3. **Catch errors early** with proper validation
4. **Debug issues quickly** with good logging
5. **Run tests efficiently** with optimized patterns

Remember: The time spent setting up proper test patterns saves multiples of that time in debugging later.