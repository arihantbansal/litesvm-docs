---
title: LiteSVM Core API
description: Complete reference for the core LiteSVM struct and its methods
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# LiteSVM Core API

The main `LiteSVM` struct provides all core functionality for testing Solana programs.

## Creating a LiteSVM Instance

### `new()`

Creates a new LiteSVM instance with default configuration.

```rust
pub fn new() -> LiteSVM
```

**Returns**: A configured `LiteSVM` instance with:

- All runtime features enabled
- Default sysvars initialized
- Built-in programs (System, Token, etc.) loaded
- Signature verification enabled
- Blockhash validation enabled

**Example**:

```rust
use litesvm::LiteSVM;

let mut svm = LiteSVM::new();
```

### Configuration Methods

#### `with_compute_budget(budget: ComputeBudget)`

Sets custom compute budget limits.

```rust
let mut svm = LiteSVM::new()
    .with_compute_budget(ComputeBudget {
        compute_unit_limit: 1_400_000,
        heap_size: 256 * 1024,
        ..Default::default()
    });
```

#### `with_sigverify(enabled: bool)`

Enables or disables signature verification.

```rust
let mut svm = LiteSVM::new()
    .with_sigverify(false); // Disable for faster tests
```

#### `with_blockhash_check(enabled: bool)`

Enables or disables blockhash validation.

```rust
let mut svm = LiteSVM::new()
    .with_blockhash_check(false); // Disable for simpler tests
```

#### `with_lamports(lamports: u64)`

Sets the initial balance for fee payer accounts.

```rust
let mut svm = LiteSVM::new()
    .with_lamports(100_000_000_000); // 100 SOL
```

## Transaction Methods

### `send_transaction()`

Executes a signed transaction and modifies state.

```rust
pub fn send_transaction(
    &mut self,
    tx: impl Into<VersionedTransaction>
) -> Result<TransactionMetadata, TransactionError>
```

**Parameters**:

- `tx`: A signed transaction (can be `Transaction` or `VersionedTransaction`)

**Returns**:

- `Ok(TransactionMetadata)` containing:
  - `compute_units_consumed`: Number of compute units used
  - `logs`: Transaction execution logs
  - `return_data`: Program return data (if any)
- `Err(TransactionError)` with error details and partial metadata

**Example**:

```rust
let tx = Transaction::new_signed_with_payer(
    &[instruction],
    Some(&payer.pubkey()),
    &[&payer],
    svm.latest_blockhash(),
);

match svm.send_transaction(tx) {
    Ok(result) => {
        println!("Compute units: {}", result.compute_units_consumed);
        println!("Logs: {:?}", result.logs);
    }
    Err(err) => {
        println!("Error: {:?}", err);
        // Access logs even on failure
        if let Some(logs) = err.meta.as_ref().map(|m| &m.logs) {
            println!("Failure logs: {:?}", logs);
        }
    }
}
```

### `simulate_transaction()`

Simulates a transaction without modifying state.

```rust
pub fn simulate_transaction(
    &self,
    tx: impl Into<VersionedTransaction>
) -> Result<SimulatedTransactionInfo, FailedTransactionMetadata>
```

**Parameters**:

- `tx`: A transaction to simulate (signatures not required)

**Returns**:

- `Ok(SimulatedTransactionInfo)` with simulation results
- `Err(FailedTransactionMetadata)` with failure details

**Example**:

```rust
// Simulate before sending to check for errors
let simulation = svm.simulate_transaction(&tx);
if simulation.is_ok() {
    let result = svm.send_transaction(tx).unwrap();
}
```

## Account Methods

### `get_account()`

Retrieves account information.

```rust
pub fn get_account(&self, pubkey: &Pubkey) -> Option<Account>
```

**Parameters**:

- `pubkey`: The account's public key

**Returns**:

- `Some(Account)` if the account exists
- `None` if the account doesn't exist

<Callout type="warning">
  **Important**: Closed accounts may still return `Some(Account)` with zero
  lamports. Always check both existence and account state.
</Callout>

**Example**:

```rust
// Check if account exists
let account = svm.get_account(&pubkey);
match account {
    Some(acc) => {
        println!("Balance: {} lamports", acc.lamports);
        println!("Owner: {}", acc.owner);
        println!("Data length: {}", acc.data.len());

        // Check if account is effectively closed
        if acc.lamports == 0 || acc.data.is_empty() {
            println!("Account is closed");
        }
    }
    None => println!("Account does not exist"),
}
```

### `get_balance()`

Gets the lamport balance of an account.

```rust
pub fn get_balance(&self, pubkey: &Pubkey) -> Result<u64, LiteSVMError>
```

**Returns**:

- `Ok(balance)`: The account's balance in lamports
- `Err`: If the account doesn't exist

**Example**:

```rust
let balance = svm.get_balance(&pubkey).unwrap();
println!("Balance: {} SOL", balance as f64 / 1e9);
```

### `airdrop()`

Transfers lamports to an account (for testing).

```rust
pub fn airdrop(
    &mut self,
    pubkey: &Pubkey,
    lamports: u64
) -> Result<(), TransactionError>
```

**Parameters**:

- `pubkey`: Recipient's public key
- `lamports`: Amount to transfer

**Example**:

```rust
// Give account 10 SOL
svm.airdrop(&account.pubkey(), 10_000_000_000).unwrap();
```

## Program Management

### `add_program()`

Deploys a program from bytes.

```rust
pub fn add_program(
    &mut self,
    program_id: impl Into<Pubkey>,
    program_bytes: &[u8]
) -> Result<(), LiteSVMError>
```

**Parameters**:

- `program_id`: The program's public key (must match the program's keypair)
- `program_bytes`: Compiled program bytes (.so file contents)

**Example**:

```rust
// Correct way - ensure ID matches keypair
let program_bytes = include_bytes!("../target/deploy/program.so");
let program_keypair = read_keypair_file("target/deploy/program-keypair.json").unwrap();
let program_id = program_keypair.pubkey();

svm.add_program(program_id, program_bytes).unwrap();

// Verify deployment
assert!(svm.get_account(&program_id).is_some());
assert!(svm.get_account(&program_id).unwrap().executable);
```

### `add_program_from_file()`

Deploys a program from a file path.

```rust
pub fn add_program_from_file(
    &mut self,
    program_id: impl Into<Pubkey>,
    path: impl AsRef<Path>
) -> Result<(), LiteSVMError>
```

**Parameters**:

- `program_id`: The program's public key
- `path`: Path to the compiled .so file

**Example**:

```rust
svm.add_program_from_file(
    program_id,
    "target/deploy/program.so"
).unwrap();
```

## Blockchain State Methods

### `latest_blockhash()`

Gets the current blockhash for transaction signing.

```rust
pub fn latest_blockhash(&self) -> Hash
```

**Returns**: The current blockhash

**Example**:

```rust
let blockhash = svm.latest_blockhash();
let tx = Transaction::new_signed_with_payer(
    &[instruction],
    Some(&payer.pubkey()),
    &[&payer],
    blockhash,
);
```

### `set_clock()`

Advances the blockchain clock (for time-based testing).

```rust
pub fn set_clock(&mut self, unix_timestamp: i64)
```

**Parameters**:

- `unix_timestamp`: Unix timestamp in seconds

**Example**:

```rust
// Set time to specific timestamp
svm.set_clock(1700000000);

// Advance time by 1 hour
let current = svm.get_sysvar::<Clock>().unix_timestamp;
svm.set_clock(current + 3600);
```

### `warp_to_slot()`

Advances to a specific slot number.

```rust
pub fn warp_to_slot(&mut self, slot: u64)
```

**Example**:

```rust
// Jump to slot 1000
svm.warp_to_slot(1000);
```

## Helper Methods

### `minimum_balance_for_rent_exemption()`

Calculates rent-exempt balance for a data size.

```rust
pub fn minimum_balance_for_rent_exemption(&self, data_len: usize) -> u64
```

**Parameters**:

- `data_len`: Size of account data in bytes

**Returns**: Minimum lamports needed for rent exemption

**Example**:

```rust
// Calculate rent for a 100-byte account
let rent = svm.minimum_balance_for_rent_exemption(100);
```

### `get_token_account()`

Helper to deserialize a token account.

```rust
pub fn get_token_account(&self, pubkey: &Pubkey) -> Option<TokenAccount>
```

**Returns**: Deserialized SPL token account data

**Example**:

```rust
let token_account = svm.get_token_account(&ata).unwrap();
println!("Token balance: {}", token_account.amount);
println!("Token mint: {}", token_account.mint);
```

## Error Handling

### TransactionError

Common transaction errors and their meanings:

| Error                        | Description                          | Common Cause                                        |
| ---------------------------- | ------------------------------------ | --------------------------------------------------- |
| `InsufficientFunds`          | Account doesn't have enough lamports | Forgot to airdrop or insufficient balance           |
| `InvalidProgramForExecution` | Program not found                    | Program not deployed or wrong program ID            |
| `PrivilegeEscalation`        | Unauthorized account modification    | Account not marked writable when receiving lamports |
| `AccountNotFound`            | Referenced account doesn't exist     | Account needs to be created first                   |
| `InvalidAccountData`         | Account data is invalid              | Token accounts not properly initialized             |

### Debugging Failed Transactions

```rust
match svm.send_transaction(tx) {
    Err(err) => {
        // Print the main error
        println!("Transaction failed: {:?}", err);

        // Access detailed metadata
        if let Some(meta) = &err.meta {
            println!("Compute units consumed: {}", meta.compute_units_consumed);

            // Print all logs for debugging
            for log in &meta.logs {
                println!("  {}", log);
            }

            // Check for custom program errors
            if log.contains("custom program error") {
                // Parse error code and check program's error enum
            }
        }
    }
    Ok(_) => {}
}
```

## Best Practices

1. **Always verify program deployment**:

   ```rust
   svm.add_program(program_id, &bytes).unwrap();
   assert!(svm.get_account(&program_id).unwrap().executable);
   ```

2. **Check account existence before operations**:

   ```rust
   if svm.get_account(&pubkey).is_none() {
       // Create account first
   }
   ```

3. **Handle all transaction results**:

   ```rust
   let result = svm.send_transaction(tx)?;
   // Don't ignore the result
   ```

4. **Use simulation for complex transactions**:
   ```rust
   // Simulate first to catch errors
   svm.simulate_transaction(&tx)?;
   // Then send if simulation succeeds
   svm.send_transaction(tx)?;
   ```
