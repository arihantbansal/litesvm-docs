---
title: Debugging Guide
description: Techniques and tools for debugging LiteSVM tests effectively
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

# Debugging Guide

Master the art of debugging Solana program tests with LiteSVM using these techniques and patterns.

## Understanding Transaction Failures

### Anatomy of an Error

When a transaction fails, LiteSVM provides detailed information:

```rust
match svm.send_transaction(tx) {
    Err(err) => {
        // err contains:
        // - err.err: The actual error type
        // - err.meta: Optional metadata with logs and compute units

        println!("Error type: {:?}", err.err);

        if let Some(meta) = &err.meta {
            println!("Compute units before failure: {}", meta.compute_units_consumed);
            println!("\nTransaction logs:");
            for log in &meta.logs {
                println!("  {}", log);
            }
        }
    }
    Ok(_) => {}
}
```

### Log Analysis

Transaction logs provide crucial debugging information:

```rust
fn analyze_transaction_logs(logs: &[String]) {
    for log in logs {
        // Program entry/exit
        if log.starts_with("Program") && log.contains("invoke") {
            println!("üì• {}", log);
        } else if log.starts_with("Program") && log.contains("success") {
            println!("‚úÖ {}", log);
        } else if log.starts_with("Program") && log.contains("failed") {
            println!("‚ùå {}", log);
        }
        // Program logs
        else if log.starts_with("Program log:") {
            let msg = log.strip_prefix("Program log: ").unwrap_or(log);
            println!("üìù {}", msg);

            // Check for common issues
            if msg.contains("insufficient") {
                println!("   ‚ö†Ô∏è Funds issue detected");
            } else if msg.contains("already in use") {
                println!("   ‚ö†Ô∏è Account already initialized");
            } else if msg.contains("constraint") {
                println!("   ‚ö†Ô∏è Constraint violation");
            }
        }
        // System logs
        else {
            println!("   {}", log);
        }
    }
}
```

## Debugging Techniques

### 1. State Inspection

Create helper functions to inspect account state at any point:

```rust
struct AccountInspector<'a> {
    svm: &'a LiteSVM,
}

impl<'a> AccountInspector<'a> {
    fn new(svm: &'a LiteSVM) -> Self {
        Self { svm }
    }

    fn inspect(&self, pubkey: &Pubkey, label: &str) {
        println!("\nüîç Inspecting {}", label);
        println!("   Address: {}", pubkey);

        match self.svm.get_account(pubkey) {
            Some(account) => {
                println!("   ‚úÖ Account exists");
                println!("   Balance: {} lamports ({:.6} SOL)",
                    account.lamports,
                    account.lamports as f64 / 1e9
                );
                println!("   Owner: {}", account.owner);
                println!("   Executable: {}", account.executable);
                println!("   Data size: {} bytes", account.data.len());

                // Try to decode as different account types
                self.try_decode_account(&account, pubkey);
            }
            None => {
                println!("   ‚ùå Account does not exist");
            }
        }
    }

    fn try_decode_account(&self, account: &Account, pubkey: &Pubkey) {
        // Try as token account
        if account.owner == spl_token::id() && account.data.len() == 165 {
            if let Some(token_account) = self.svm.get_token_account(pubkey) {
                println!("\n   üì¶ Token Account:");
                println!("      Mint: {}", token_account.mint);
                println!("      Owner: {}", token_account.owner);
                println!("      Balance: {}", token_account.amount);
                println!("      State: {:?}", token_account.state);
            }
        }
        // Try as mint
        else if account.owner == spl_token::id() && account.data.len() == 82 {
            println!("\n   ü™ô Token Mint");
            // Decode mint data if needed
        }
        // Program account
        else if account.executable {
            println!("\n   üìú Executable Program");
        }
    }

    fn compare_before_after(
        &self,
        pubkey: &Pubkey,
        label: &str,
        operation: impl FnOnce() -> Result<(), Box<dyn std::error::Error>>
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Capture before state
        let before = self.svm.get_account(pubkey).map(|a| a.lamports);
        println!("\nüìä {} - Before: {:?} lamports", label, before);

        // Execute operation
        operation()?;

        // Capture after state
        let after = self.svm.get_account(pubkey).map(|a| a.lamports);
        println!("üìä {} - After: {:?} lamports", label, after);

        if let (Some(b), Some(a)) = (before, after) {
            let diff = a as i64 - b as i64;
            println!("üìä Change: {:+} lamports", diff);
        }

        Ok(())
    }
}

// Usage
let inspector = AccountInspector::new(&svm);
inspector.inspect(&escrow_pda, "Escrow PDA");
inspector.inspect(&token_account, "Token Account");
```

### 2. Transaction Simulation

Always simulate before sending to get better error messages:

```rust
fn debug_transaction(
    svm: &mut LiteSVM,
    tx: Transaction,
) -> Result<TransactionMetadata, Box<dyn std::error::Error>> {
    println!("\nüîÑ Simulating transaction...");

    // First simulate
    match svm.simulate_transaction(&tx) {
        Ok(info) => {
            println!("‚úÖ Simulation successful");
            println!("   Compute units: {}", info.units_consumed);
            println!("   Logs: {} entries", info.logs.len());
        }
        Err(err) => {
            println!("‚ùå Simulation failed: {:?}", err.err);

            if let Some(meta) = &err.meta {
                println!("\nüìã Simulation logs:");
                for log in &meta.logs {
                    if log.contains("error") || log.contains("failed") {
                        println!("   ‚ùå {}", log);
                    } else if log.starts_with("Program log:") {
                        println!("   üìù {}", log);
                    } else {
                        println!("      {}", log);
                    }
                }
            }

            return Err(format!("Simulation failed: {:?}", err.err).into());
        }
    }

    // If simulation passed, send the transaction
    println!("\nüì§ Sending transaction...");
    match svm.send_transaction(tx) {
        Ok(result) => {
            println!("‚úÖ Transaction successful!");
            println!("   Compute units: {}", result.compute_units_consumed);
            Ok(result)
        }
        Err(err) => {
            println!("‚ùå Transaction failed: {:?}", err);
            Err(err.into())
        }
    }
}
```

### 3. Instruction Breakdown

Debug complex transactions by breaking down instructions:

```rust
fn debug_instruction(
    ix: &Instruction,
    account_keys: &[Pubkey],
) {
    println!("\nüì¶ Instruction Debug:");
    println!("   Program: {}", ix.program_id);
    println!("   Data length: {} bytes", ix.data.len());

    // Decode instruction data if possible
    if !ix.data.is_empty() {
        println!("   Data (first 8 bytes): {:?}",
            &ix.data[..ix.data.len().min(8)]
        );
    }

    println!("   Accounts ({}):", ix.accounts.len());
    for (i, account_idx) in ix.accounts.iter().enumerate() {
        let pubkey = &account_keys[*account_idx as usize];
        let meta = if i == 0 { "(fee payer)" } else { "" };
        println!("      [{}] {} {}", i, pubkey, meta);
    }
}

fn debug_transaction_structure(tx: &Transaction) {
    println!("\nüîç Transaction Structure:");
    println!("   Instructions: {}", tx.message.instructions.len());
    println!("   Signers: {}", tx.signatures.len());
    println!("   Recent blockhash: {}", tx.message.recent_blockhash);

    for (i, ix) in tx.message.instructions.iter().enumerate() {
        println!("\n   Instruction {}:", i);
        debug_instruction(ix, &tx.message.account_keys);
    }
}
```

### 4. Binary Search Debugging

For complex test failures, use binary search to isolate the problem:

```rust
fn binary_search_debug<T>(
    operations: Vec<(&str, Box<dyn Fn() -> Result<T, Box<dyn std::error::Error>>>)>,
) -> Result<Vec<T>, Box<dyn std::error::Error>> {
    let mut results = Vec::new();
    let mut last_good = 0;

    println!("\nüîç Binary Search Debug: {} operations", operations.len());

    for (i, (name, op)) in operations.into_iter().enumerate() {
        println!("\n[{}/{}] Running: {}", i + 1, operations.len(), name);

        match op() {
            Ok(result) => {
                println!("   ‚úÖ Success");
                results.push(result);
                last_good = i;
            }
            Err(err) => {
                println!("   ‚ùå Failed: {:?}", err);
                println!("\nüìç Problem isolated:");
                println!("   Last successful: Operation {}", last_good);
                println!("   Failed at: Operation {} ({})", i, name);
                return Err(format!("Failed at operation {}: {}", name, err).into());
            }
        }
    }

    Ok(results)
}

// Usage
let operations: Vec<(&str, Box<dyn Fn() -> Result<(), Box<dyn std::error::Error>>>)> = vec![
    ("Deploy program", Box::new(|| deploy_program(&mut svm))),
    ("Create mint", Box::new(|| create_mint(&mut svm))),
    ("Create accounts", Box::new(|| create_accounts(&mut svm))),
    ("Execute instruction", Box::new(|| execute_instruction(&mut svm))),
];

binary_search_debug(operations)?;
```

## Advanced Debugging Patterns

### PDA Debugging

Debug PDA derivation issues:

```rust
fn debug_pda_derivation(
    seeds: &[&[u8]],
    program_id: &Pubkey,
) -> (Pubkey, u8) {
    println!("\nüîë PDA Derivation Debug:");
    println!("   Program ID: {}", program_id);
    println!("   Seeds:");

    for (i, seed) in seeds.iter().enumerate() {
        println!("      [{}] Length: {} bytes", i, seed.len());
        if seed.len() <= 32 {
            // Try to interpret as string
            if let Ok(s) = std::str::from_utf8(seed) {
                println!("          As string: \"{}\"", s);
            }
            // Show as hex
            println!("          As hex: 0x{}", hex::encode(seed));
        }
    }

    let (pda, bump) = Pubkey::find_program_address(seeds, program_id);
    println!("   Derived PDA: {}", pda);
    println!("   Bump seed: {}", bump);

    (pda, bump)
}
```

### CPI Debugging

Debug cross-program invocations:

```rust
fn debug_cpi_context(
    caller_program: &Pubkey,
    callee_program: &Pubkey,
    accounts: &[AccountInfo],
) {
    println!("\nüîÑ CPI Debug:");
    println!("   Caller: {}", caller_program);
    println!("   Callee: {}", callee_program);
    println!("   Accounts passed: {}", accounts.len());

    for (i, account) in accounts.iter().enumerate() {
        println!("\n   Account [{}]:", i);
        println!("      Key: {}", account.key);
        println!("      Owner: {}", account.owner);
        println!("      Writable: {}", account.is_writable);
        println!("      Signer: {}", account.is_signer);
        println!("      Lamports: {}", account.lamports());
    }
}
```

### Time-based Debugging

Debug time-dependent logic:

```rust
fn debug_time_progression(
    svm: &mut LiteSVM,
    checkpoints: Vec<(i64, &str, Box<dyn Fn(&mut LiteSVM) -> Result<(), Box<dyn std::error::Error>>>)>,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("\n‚è∞ Time-based Debug:");

    for (timestamp, label, operation) in checkpoints {
        svm.set_clock(timestamp);
        let clock = svm.get_sysvar::<Clock>();

        println!("\nüïê Time: {} ({})", timestamp, label);
        println!("   Slot: {}", clock.slot);
        println!("   Epoch: {}", clock.epoch);

        match operation(svm) {
            Ok(_) => println!("   ‚úÖ Operation successful"),
            Err(err) => {
                println!("   ‚ùå Operation failed: {:?}", err);
                return Err(err);
            }
        }
    }

    Ok(())
}
```

## Debugging Checklist

When debugging a failing test:

<Steps>
<Step>
**Check Account Existence**
```rust
assert!(svm.get_account(&account).is_some(), "Account doesn't exist");
```
</Step>

<Step>
**Verify Program Deployment**
```rust
assert!(svm.get_account(&program_id).unwrap().executable);
```
</Step>

<Step>
**Validate Account Permissions**
```rust
// Ensure writable for accounts receiving lamports
AccountMeta::new(recipient, false)  // not new_readonly
```
</Step>

<Step>
**Initialize All Mints**
```rust
initialize_mint(&mut svm, &authority, &mint, 9);
```
</Step>

<Step>
**Check PDA Derivation**
```rust
let (pda, _) = Pubkey::find_program_address(&seeds, &program_id);
assert_eq!(pda, expected_pda);
```
</Step>

<Step>
**Simulate Before Sending**
```rust
svm.simulate_transaction(&tx)?;
```
</Step>

<Step>
**Analyze Logs**
```rust
for log in &error.meta.unwrap().logs {
    println!("{}", log);
}
```
</Step>
</Steps>

## Performance Debugging

### Measuring Compute Units

```rust
fn measure_compute_units(
    svm: &mut LiteSVM,
    operations: Vec<(&str, Transaction)>,
) {
    println!("\nüìä Compute Unit Analysis:");

    let mut total_units = 0u64;

    for (name, tx) in operations {
        match svm.send_transaction(tx) {
            Ok(result) => {
                let units = result.compute_units_consumed;
                total_units += units;

                println!("   {} {}: {} units",
                    if units > 100_000 { "‚ö†Ô∏è" } else { "‚úÖ" },
                    name,
                    units
                );
            }
            Err(err) => {
                println!("   ‚ùå {}: Failed - {:?}", name, err);
            }
        }
    }

    println!("\n   Total: {} units", total_units);
    if total_units > 1_400_000 {
        println!("   ‚ö†Ô∏è Warning: Exceeds single transaction limit");
    }
}
```

## Common Debug Scenarios

### "Why is my account not found?"

```rust
fn debug_account_not_found(svm: &LiteSVM, pubkey: &Pubkey) {
    println!("\nüîç Debugging AccountNotFound for {}", pubkey);

    // Check if it's a PDA
    for program in [system_program::id(), spl_token::id(), /* your_program */] {
        for bump in 250..=255 {
            let seeds = &[b"common", b"seed", &[bump]];
            let (pda, _) = Pubkey::find_program_address(seeds, &program);
            if pda == *pubkey {
                println!("   Found as PDA with bump {} for program {}", bump, program);
                return;
            }
        }
    }

    // Check if it's an ATA
    // ... similar checks
}
```

### "Why does my transaction simulation pass but execution fail?"

```rust
fn debug_simulation_vs_execution(
    svm: &mut LiteSVM,
    tx: Transaction,
) {
    // Capture state before simulation
    let state_before = capture_state(svm);

    // Simulate
    let sim_result = svm.simulate_transaction(&tx);

    // State shouldn't change after simulation
    let state_after_sim = capture_state(svm);
    assert_eq!(state_before, state_after_sim, "State changed during simulation!");

    // Now execute
    let exec_result = svm.send_transaction(tx);

    println!("Simulation: {:?}", sim_result.is_ok());
    println!("Execution: {:?}", exec_result.is_ok());
}
```

## Summary

Effective debugging in LiteSVM requires:

1. **Understanding error structures** - Use all available metadata
2. **Strategic logging** - Add logs at critical points
3. **State inspection** - Check accounts before and after operations
4. **Simulation first** - Always simulate complex transactions
5. **Binary search** - Isolate failures in complex test sequences
6. **Tool creation** - Build debugging utilities specific to your program

Remember: The time invested in building good debugging tools pays off many times over when tracking down subtle issues.