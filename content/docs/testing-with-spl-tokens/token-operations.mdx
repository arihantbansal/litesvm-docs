---
title: Token Operations
description: Working with token operations - minting, transfers, and account management
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

# Token Operations

Learn how to perform common token operations including creating mints, minting tokens, and transferring tokens between accounts.

## Creating a Token Mint

A mint is the foundation of any SPL token. It defines the token's properties and controls who can mint new tokens.

```rust
use litesvm::LiteSVM;
use litesvm_token::{CreateMint, CreateAssociatedTokenAccount, MintTo, Transfer};
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};

#[test]
fn test_create_mint() {
    let mut svm = LiteSVM::new();
    let authority = Keypair::new();

    // Fund the authority account
    svm.airdrop(&authority.pubkey(), 10_000_000_000).unwrap();

    // Create a new mint with 9 decimals (like SOL)
    let mint = Keypair::new();
    let decimals = 9;

    let create_mint_ix = CreateMint::new(
        &mint.pubkey(),
        &authority.pubkey(),
        Some(&authority.pubkey()), // freeze authority (optional)
        decimals,
    );

    let tx_result = svm.send_transaction(create_mint_ix.instructions(&[&authority, &mint]));
    assert!(tx_result.is_ok());
}
```

## Creating Associated Token Accounts

Associated Token Accounts (ATAs) are deterministic addresses for holding tokens, making them predictable and easy to work with.

```rust
#[test]
fn test_create_ata() {
    let mut svm = LiteSVM::new();
    let owner = Keypair::new();
    let mint = Keypair::new();

    // Fund and create mint first
    svm.airdrop(&owner.pubkey(), 10_000_000_000).unwrap();

    // Create the mint
    let create_mint_ix = CreateMint::new(
        &mint.pubkey(),
        &owner.pubkey(),
        None,
        9,
    );
    svm.send_transaction(create_mint_ix.instructions(&[&owner, &mint])).unwrap();

    // Create ATA for the owner
    let create_ata_ix = CreateAssociatedTokenAccount {
        funder: &owner.pubkey(),
        owner: &owner.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };

    let tx_result = svm.send_transaction(create_ata_ix.instruction(&[&owner]));
    assert!(tx_result.is_ok());

    // The ATA address is deterministic
    let ata = spl_associated_token_account::get_associated_token_address(
        &owner.pubkey(),
        &mint.pubkey(),
    );

    // Verify the account exists
    let account = svm.get_account(&ata).unwrap();
    assert!(account.lamports > 0);
}
```

## Minting Tokens

Once you have a mint and token accounts, you can mint tokens to those accounts.

```rust
#[test]
fn test_mint_tokens() {
    let mut svm = LiteSVM::new();
    let authority = Keypair::new();
    let mint = Keypair::new();
    let recipient = Keypair::new();

    // Setup: Fund accounts and create mint
    svm.airdrop(&authority.pubkey(), 10_000_000_000).unwrap();
    svm.airdrop(&recipient.pubkey(), 10_000_000_000).unwrap();

    // Create mint
    let decimals = 6;
    let create_mint_ix = CreateMint::new(
        &mint.pubkey(),
        &authority.pubkey(),
        None,
        decimals,
    );
    svm.send_transaction(create_mint_ix.instructions(&[&authority, &mint])).unwrap();

    // Create recipient's token account
    let create_ata_ix = CreateAssociatedTokenAccount {
        funder: &recipient.pubkey(),
        owner: &recipient.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };
    svm.send_transaction(create_ata_ix.instruction(&[&recipient])).unwrap();

    // Mint 1000 tokens (with decimals)
    let recipient_ata = spl_associated_token_account::get_associated_token_address(
        &recipient.pubkey(),
        &mint.pubkey(),
    );

    let amount = 1000 * 10_u64.pow(decimals as u32); // 1000 tokens
    let mint_to_ix = MintTo {
        mint: &mint.pubkey(),
        destination: &recipient_ata,
        authority: &authority.pubkey(),
        amount,
    };

    let tx_result = svm.send_transaction(mint_to_ix.instruction(&[&authority]));
    assert!(tx_result.is_ok());

    // Verify balance
    let token_account = svm.get_token_account(&recipient_ata).unwrap();
    assert_eq!(token_account.amount, amount);
}
```

## Token Transfers

Transfer tokens between accounts using the Transfer instruction.

```rust
#[test]
fn test_token_transfer() {
    let mut svm = LiteSVM::new();
    let authority = Keypair::new();
    let mint = Keypair::new();
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Setup: Fund all accounts
    svm.airdrop(&authority.pubkey(), 10_000_000_000).unwrap();
    svm.airdrop(&sender.pubkey(), 10_000_000_000).unwrap();
    svm.airdrop(&recipient.pubkey(), 10_000_000_000).unwrap();

    // Create mint
    let decimals = 9;
    let create_mint_ix = CreateMint::new(
        &mint.pubkey(),
        &authority.pubkey(),
        None,
        decimals,
    );
    svm.send_transaction(create_mint_ix.instructions(&[&authority, &mint])).unwrap();

    // Create token accounts for both sender and recipient
    let sender_ata = spl_associated_token_account::get_associated_token_address(
        &sender.pubkey(),
        &mint.pubkey(),
    );
    let recipient_ata = spl_associated_token_account::get_associated_token_address(
        &recipient.pubkey(),
        &mint.pubkey(),
    );

    // Create sender's ATA
    let create_sender_ata_ix = CreateAssociatedTokenAccount {
        funder: &sender.pubkey(),
        owner: &sender.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };
    svm.send_transaction(create_sender_ata_ix.instruction(&[&sender])).unwrap();

    // Create recipient's ATA
    let create_recipient_ata_ix = CreateAssociatedTokenAccount {
        funder: &recipient.pubkey(),
        owner: &recipient.pubkey(),
        mint: &mint.pubkey(),
        token_program: &spl_token::id(),
    };
    svm.send_transaction(create_recipient_ata_ix.instruction(&[&recipient])).unwrap();

    // Mint tokens to sender
    let mint_amount = 1000 * 10_u64.pow(decimals as u32);
    let mint_to_ix = MintTo {
        mint: &mint.pubkey(),
        destination: &sender_ata,
        authority: &authority.pubkey(),
        amount: mint_amount,
    };
    svm.send_transaction(mint_to_ix.instruction(&[&authority])).unwrap();

    // Transfer tokens from sender to recipient
    let transfer_amount = 250 * 10_u64.pow(decimals as u32);
    let transfer_ix = Transfer {
        source: &sender_ata,
        destination: &recipient_ata,
        authority: &sender.pubkey(),
        amount: transfer_amount,
    };

    let tx_result = svm.send_transaction(transfer_ix.instruction(&[&sender]));
    assert!(tx_result.is_ok());

    // Verify balances
    let sender_balance = svm.get_token_account(&sender_ata).unwrap();
    let recipient_balance = svm.get_token_account(&recipient_ata).unwrap();

    assert_eq!(sender_balance.amount, mint_amount - transfer_amount);
    assert_eq!(recipient_balance.amount, transfer_amount);
}
```

## Working with Decimals

Most tokens use decimals to represent fractional amounts. Here's how to handle them correctly:

```rust
// For a token with 6 decimals (like USDC)
let decimals = 6;
let one_token = 10_u64.pow(decimals as u32);
let amount_tokens = 100; // Want to send 100 tokens
let amount_raw = amount_tokens * one_token; // 100,000,000 raw units

// For a token with 9 decimals (like SOL)
let decimals = 9;
let one_sol = 10_u64.pow(decimals as u32);
let amount_sol = 1.5; // Want to send 1.5 SOL
let amount_lamports = (amount_sol * one_sol as f64) as u64; // 1,500,000,000 lamports
```

## Batch Operations

When performing multiple token operations, batch them in a single transaction for efficiency:

```rust
use solana_sdk::instruction::Instruction;

#[test]
fn test_batch_operations() {
    let mut svm = LiteSVM::new();
    // ... setup code ...

    let mut instructions: Vec<Instruction> = vec![];

    // Add multiple mint instructions
    for recipient_ata in recipient_atas.iter() {
        let mint_ix = MintTo {
            mint: &mint.pubkey(),
            destination: recipient_ata,
            authority: &authority.pubkey(),
            amount: 100 * 10_u64.pow(decimals as u32),
        };
        instructions.push(mint_ix.instruction_no_signature());
    }

    // Send all instructions in one transaction
    let tx_result = svm.send_transaction(instructions);
    assert!(tx_result.is_ok());
}
```

## Error Testing

Test error conditions to ensure your program handles them correctly:

```rust
#[test]
fn test_insufficient_balance_error() {
    let mut svm = LiteSVM::new();
    // ... setup code ...

    // Try to transfer more than available balance
    let excessive_amount = sender_balance + 1;
    let transfer_ix = Transfer {
        source: &sender_ata,
        destination: &recipient_ata,
        authority: &sender.pubkey(),
        amount: excessive_amount,
    };

    let tx_result = svm.send_transaction(transfer_ix.instruction(&[&sender]));
    assert!(tx_result.is_err());

    // Verify the specific error if needed
    if let Err(e) = tx_result {
        // Check error message or code
        assert!(e.to_string().contains("insufficient"));
    }
}
```
